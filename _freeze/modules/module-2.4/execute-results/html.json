{
  "hash": "ddafcc44254c404c7f720bd5cef1d0e1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 2.4\"\nsubtitle: \"Joining Data Frames\"\nformat: \n  html:\n    code-link: true\nhighlight-style: atom-one\nexecute: \n  echo: true\n  message: false\n  warning: false\n---\n\n::: {.callout-tip}\n## Prework\n\n- Start a QMD file for this module.\n- Install the `WDI` package and study [the documentation](https://vincentarelbundock.github.io/WDI/)\n- Visit the [World Development Indicators database](https://databank.worldbank.org/source/world-development-indicators) and explore the available indicators.\n- Install the `countrycode` package and [read about it](https://vincentarelbundock.github.io/countrycode/).\n- Read about [mutating joins](https://dplyr.tidyverse.org/reference/mutate-joins.html) in `dplyr`.\n:::\n\n## Overview\n\nIn this module, we will learn how to join data frames in R using the `dplyr` package. Joining data frames is a fundamental operation in data analysis, allowing you to combine information from different sources based on common keys. We will explore various types of joins, including inner joins, left joins, right joins, and full joins, and apply a left join to merge two real-world datasets. \n\n\n## Packages for API Data\n\nAs more organizations publish their data online, APIs—Application Programming Interfaces—have become a standard way to provide structured access to that information. Rather than downloading spreadsheets or scraping websites, we can use R code to request data directly from a server and receive it in a tidy format.\n\nIn R, a growing number of packages are designed specifically to help you access data from these APIs. These tools handle the technical details of connecting to the API and parsing the response, so you can focus on analysis. Packages like `WDI` and `wbstats` (for World Bank data), `fredr` (for U.S. Federal Reserve data), and `tidycensus` (for U.S. Census data) make it much easier to pull data into your workflow with just a few lines of code.\n\nIn this module, we will use the `WDI` package by Vincent Arel-Bundock to access data from the World Bank’s open data API. The package provides a streamlined interface to over 40 datasets published by the World Bank, including the World Development Indicators, Gender Statistics, Education Statistics, and more. These databases cover a wide range of topics such as health, labor, infrastructure, environment, and governance, with data available for nearly every country in the world. The package returns the data in a tidy format, making it easy to integrate into your analysis workflow.\n\nThe basic syntax for using the `WDI` package is as follows:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(WDI)\nlibrary(dplyr)\n\nwbdata <- WDI(\n  indicator = \"NY.GDP.PCAP.KD\", # per capita GDP in constant US dollars\n  country = c(\"USA\", \"CAN\", \"MEX\"), # Countries to include\n  start = 2000, # Start year\n  end = 2020, # End year\n  extra = TRUE # Include extra metadata (default is FALSE)\n)\n\nglimpse(wbdata)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 63\nColumns: 13\n$ country        <chr> \"Canada\", \"Canada\", \"Canada\", \"Canada\", \"Canada\", \"Cana…\n$ iso2c          <chr> \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"…\n$ iso3c          <chr> \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\",…\n$ year           <int> 2020, 2019, 2018, 2017, 2016, 2015, 2014, 2013, 2012, 2…\n$ NY.GDP.PCAP.KD <dbl> 42366.129, 45100.291, 44907.344, 44339.389, 43551.343, …\n$ status         <chr> \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",…\n$ lastupdated    <chr> \"2025-04-15\", \"2025-04-15\", \"2025-04-15\", \"2025-04-15\",…\n$ region         <chr> \"North America\", \"North America\", \"North America\", \"Nor…\n$ capital        <chr> \"Ottawa\", \"Ottawa\", \"Ottawa\", \"Ottawa\", \"Ottawa\", \"Otta…\n$ longitude      <chr> \"-75.6919\", \"-75.6919\", \"-75.6919\", \"-75.6919\", \"-75.69…\n$ latitude       <chr> \"45.4215\", \"45.4215\", \"45.4215\", \"45.4215\", \"45.4215\", …\n$ income         <chr> \"High income\", \"High income\", \"High income\", \"High inco…\n$ lending        <chr> \"Not classified\", \"Not classified\", \"Not classified\", \"…\n```\n\n\n:::\n:::\n\n\n::: {.callout-important}\n## ISO Country Codes\nThe `country` parameter takes either ISO aplha 2 or 3 codes which you can find [here](https://www.iban.com/country-codes). Familiarize yourself with these codes a bit as they will become important when we want merge datasets based on them.\n:::\n\nIf you want to download multiple indicators at once, you can pass a vector of indicator codes to the `indicator` parameter. You can also rename variables as you select them. For example:\n\n::: {.cell}\n\n```{.r .cell-code}\nindicators <- c(gdp_pc = \"NY.GDP.PCAP.KD\", population = \"SP.POP.TOTL\") \n\nwbdata2 <- WDI(\n  indicator = indicators, # GDP and total pop\n  country = c(\"USA\", \"CAN\", \"MEX\"),\n  start = 2000,\n  end = 2020\n)\n\nglimpse(wbdata2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 63\nColumns: 6\n$ country    <chr> \"Canada\", \"Canada\", \"Canada\", \"Canada\", \"Canada\", \"Canada\",…\n$ iso2c      <chr> \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\",…\n$ iso3c      <chr> \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CA…\n$ year       <int> 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,…\n$ gdp_pc     <dbl> 37906.860, 38200.456, 38921.667, 39270.023, 40108.759, 4100…\n$ population <dbl> 30685730, 31020855, 31359199, 31642461, 31938807, 32242732,…\n```\n\n\n:::\n:::\n\nThere are two ways to find indicators to download with `WDI`. One is to use the built-in `WDIsearch()` function to search for indicators by keyword, like this: \n\n::: {.cell}\n\n```{.r .cell-code}\nWDIsearch('labor force participation') |> \n  as_tibble() |> # Convert to tibble for easier viewing\n  slice(1:10) # Show first 10 results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   indicator         name                                                       \n   <chr>             <chr>                                                      \n 1 9.0.Labor.All     Labor Force Participation Rate (%)                         \n 2 9.0.Labor.B40     Labor Force Participation Rate (%)-Bottom 40 Percent       \n 3 9.0.Labor.T60     Labor Force Participation Rate (%)-Top 60 Percent          \n 4 9.1.Labor.All     Labor Force Participation Rate (%), Male                   \n 5 9.1.Labor.B40     Labor Force Participation Rate (%)-Bottom 40 Percent, Male \n 6 9.1.Labor.T60     Labor Force Participation Rate (%)-Top 60 Percent, Male    \n 7 9.2.Labor.All     Labor Force Participation Rate (%), Female                 \n 8 9.2.Labor.B40     Labor Force Participation Rate (%)-Bottom 40 Percent, Fema…\n 9 9.2.Labor.T60     Labor Force Participation Rate (%)-Top 60 Percent, Female  \n10 JI.TLF.ACTI.FE.ZS Labor force participation rate, aged 15-64, female (% of f…\n```\n\n\n:::\n:::\n\nOr with regular expressions like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nWDIsearch('labor.*participation.*female') |>\n    as_tibble() |> \n    slice(1:10) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   indicator                 name                                               \n   <chr>                     <chr>                                              \n 1 9.2.Labor.All             Labor Force Participation Rate (%), Female         \n 2 9.2.Labor.B40             Labor Force Participation Rate (%)-Bottom 40 Perce…\n 3 9.2.Labor.T60             Labor Force Participation Rate (%)-Top 60 Percent,…\n 4 JI.TLF.ACTI.FE.ZS         Labor force participation rate, aged 15-64, female…\n 5 SL.TLF.ACTI.1524.FE.NE.ZS Labor force participation rate for ages 15-24, fem…\n 6 SL.TLF.ACTI.1524.FE.ZS    Labor force participation rate for ages 15-24, fem…\n 7 SL.TLF.ACTI.FE.ZS         Labor force participation rate, female (% of femal…\n 8 SL.TLF.CACT.2534.FE.ZS    Labor participation rate, female (% of female popu…\n 9 SL.TLF.CACT.2554.FE.ZS    Labor participation rate, female (% of female popu…\n10 SL.TLF.CACT.3554.FE.ZS    Labor participation rate, female (% of female popu…\n```\n\n\n:::\n:::\n\n::: {.callout-note}\nA regular expression (or regex) is a special pattern used to match text. In WDIsearch(), regular expressions let you search for indicators based on the presence and order of words. For example, the pattern \"labor.\\*participation.\\*female\" matches any indicator name that contains the word \"labor,\" followed by \"participation,\" and then \"female,\" with any characters in between. See [this chapter](https://r4ds.hadley.nz/regexps) of *R for Data Science* for more on regular expressions.\n:::\n\nNote that here we are using the `dplyr` `slice()` function to limit the results to the first 10 rows. You can adjust this number as needed. The output will show you the indicator name, code, and description, which you can use in the `WDI()` function. We also convert the output to a tibble for easier viewing in a rendered Quarto document (but this is not necessary in a notebook or in the console).\n\nThe other way you can hunt for indicators is to browse the World Bank's [World Development Indicators database](https://databank.worldbank.org/source/world-development-indicators) directly. Here you can go to the Series tab and simply search for the indicator you are interested in. Then click on the information icon to view the indicator's code, which you can use in the `WDI()` function.\n\n::: {.callout-warning icon=false}\n## Your Turn!!\n\n- Use `WDIsearch()` to find an indicator of interest.\n- Use `WDI()` to download that variable for a country or set of countries.\n- Use `WDI()` to download multiple indicators at once.\n:::\n\n## Joining Datasets\n\nNow let's say that we want to download some data from the World Bank with `WDI` and now we want to merge it with another dataset. For example, we might want to analyze the relationship between some economic indicators like GDP and population, and some political indicators like democracy scores from the V-Dem dataset. To do this, we need to join the two datasets together based on a **common key**, which in this case is the country code.\n\nWhen we talk about a join in data wrangling, we are usually referring to a horizontal merge—that is, combining two data frames side by side by matching rows based on shared values in one or more columns (like country and year). This is common when we have data from two different sources, such as World Bank and V-Dem, and we want to analyze them together.\n\nIn dplyr, the most common joins fall into two categories: mutating joins and filtering joins. Mutating joins are the ones you’ll use most often when combining datasets. There are four main types.\n\nAn **inner join** keeps only the rows that match in both datasets. If a country-year pair is missing in either dataset, it will be dropped from the result.\n\n![*Source: R for HR*](images/inner_join.png)\n\nA **full join** keeps everything from both datasets. If a country-year pair exists in only one of them, you’ll still see it in the final data, with missing values (NA) filled in where needed.\n\n![*Source: R for HR*](images/full_join.png)\n\nA **left join** keeps all rows from the left dataset (typically the one you're focusing your analysis on) and adds columns from the right dataset wherever there’s a match.\n\n![*Source: R for HR*](images/left_join.png)\n\nA **right join** is like a left join, but it keeps all rows from the right dataset and adds data from the left wherever possible.\n\n![*Source: R for HR*](images/right_join.png)\n\nMost of the time, we will use a left join because we want to keep the structure of one main dataset and supplement it with additional information. The syntax for a left join in dplyr is straightforward:\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(data1, data2, by = \"common_column\")\n```\n:::\n\n## Common Keys (and the `countrycode` Package)\n\nThat brings us to our next point, which is that when we are joining datasets, it’s crucial to ensure that the columns you’re joining on have the same data type and format. For example, if one dataset uses ISO alpha-3 country codes (like \"USA\") and another uses alpha-2 codes (like \"US\"), you’ll need to standardize them before joining. \n\nIn the context of cross-country analysis, the `countrycode` package (also authored by Vincent Arel-Bundock) is immensely helpful. It allows you to convert between different country code formats, such as ISO alpha-2, alpha-3, numeric codes, and even country names. \n\nTo convert country codes using the `countrycode` package, you can use `mutate()` along with the `countrycode()` function. Let's try it with the `wbdata` dataset we created earlier:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(countrycode)\n\n# Convert World Bank ISO alpha-2 codes to V-Dem alpha-3 codes\nwbdata_with_vdem_codes <- wbdata2 |> \n  mutate(vdem_country_code = countrycode(\n    sourcevar = iso3c, \n    origin = \"wb\", \n    destination = \"vdem\")\n    ) |>\n  relocate(vdem_country_code, .after = iso3c)\n\nglimpse(wbdata_with_vdem_codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 63\nColumns: 7\n$ country           <chr> \"Canada\", \"Canada\", \"Canada\", \"Canada\", \"Canada\", \"C…\n$ iso2c             <chr> \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\", \"CA\"…\n$ iso3c             <chr> \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CA…\n$ vdem_country_code <dbl> 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, …\n$ year              <int> 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008…\n$ gdp_pc            <dbl> 37906.860, 38200.456, 38921.667, 39270.023, 40108.75…\n$ population        <dbl> 30685730, 31020855, 31359199, 31642461, 31938807, 32…\n```\n\n\n:::\n:::\n\nHere we are adding a new column to our `wbdata` dataset called `vdem_country_code`, which contains the V-Dem alpha-3 codes corresponding to the ISO alpha-2 codes in the `iso2c` column. The first argument in the `countrycode()` function is the vector of country codes that we want to convert, the second is the source code type (in this case, World Bank style iso3c codes or \"wb\"), and the third is the target code type (in this case, \"vdem\"). We also use the `dplyr` `relocate()` verb to move the new `vdem_country_code` column right after the original `iso3c` column for better organization.\n\n## Performing a Join\n\n{{< video https://youtu.be/wNF3ZPneHWw?si=TyiXrsAxgbdrztD4 title='Merge Two Data Frames with left_join()' >}}\n\nNow let's put it all together and use our join skills to explore the relationship between democracy and development. First we will grab the GDP per capita and population for all of the countries for the years 2000 to 2020 from the World Bank using the `WDI()` function. Then we will summarize the data across this period by taking the mean GDP per capita and population for each country. And finally we will use the `countrycode` package to convert the World Bank country codes to V-Dem country codes so we can join it with the V-Dem democracy data (which we will download next).\n\n::: {.cell}\n\n```{.r .cell-code}\nindicators <- c(\n  gdp_pc = \"NY.GDP.PCAP.KD\", \n  population = \"SP.POP.TOTL\" \n)\n\nwbdata_all_countries <- WDI(\n  indicator = indicators, \n  country = \"all\", # get data for all countries\n  start = 2000,\n  end = 2020,\n  extra = TRUE # Include extra metadata\n) |>\n  filter(region != \"Aggregates\") |> # Exclude aggregate regions\n  group_by(iso3c, region) |> # Group by country\n  summarize(\n    gdp_pc = mean(gdp_pc, na.rm = TRUE), \n    population = mean(population, na.rm = TRUE)\n  ) |> \n  ungroup() |> # Ungroup to remove grouping structure\n  mutate(vdem_country_code = countrycode(\n    sourcevar = iso3c, \n    origin = \"wb\", \n    destination = \"vdem\")\n  ) |>\n  relocate(vdem_country_code, .after = iso3c)\n\nglimpse(wbdata_all_countries)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 215\nColumns: 5\n$ iso3c             <chr> \"ABW\", \"AFG\", \"AGO\", \"ALB\", \"AND\", \"ARE\", \"ARG\", \"AR…\n$ vdem_country_code <dbl> NA, 36, 104, 12, NA, 207, 37, 105, NA, NA, 67, 144, …\n$ region            <chr> \"Latin America & Caribbean\", \"South Asia\", \"Sub-Saha…\n$ gdp_pc            <dbl> 29293.9856, 465.7585, 2761.2866, 3374.7261, 38048.31…\n$ population        <dbl> 101674.52, 28965247.52, 23886139.33, 2943197.10, 752…\n```\n\n\n:::\n:::\n\n::: {.callout-note}\n## Why `ungroup()`?\n\nAfter summarizing by country and year, we use `ungroup()` to remove the grouping structure. This ensures that any subsequent operations—like `mutate()` or joins—aren't accidentally performed within each group. It helps avoid unexpected behavior and keeps the data frame's state clean for downstream analysis.\n:::\n\nNote that when performing the merge we used a `filter()` to exclude aggregate regions like \"World\" or regional aggregates from the World Bank data. But even after doing this we will see that there are still some countries that do not have V-Dem codes. This is fine. It just meansthat V-Dem does not cover all countries, especially smaller ones or those with limited data availability. When we perform our left join, these will drop out. We could also load `tidyr` and use the `drop_na()` function to remove these rows, but we will leave them in for now.\n\nNow let's go ahead and fetch the V-Dem democracy scores for the same countries and years. We will use the `fetchdem()` function from the `vdemlite` package to get the V-Dem democracy scores, specifically the polyarchy score (`v2x_polyarchy`) and the fair elections score (`v2xel_frefair`). We will then rename these columns to make them more intuitive and then group and summarize the data so that we have one set of democracy scores per country.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vdemlite)\n\n# Fetch democracy scores for the same countries and years as wbdata\ndemocracy_scores <- fetchdem(\n  indicators = c(\"v2x_polyarchy\", \"v2xel_frefair\"),\n  start_year = 2000, end_year = 2020\n) |>\n  rename(\n    polyarchy = v2x_polyarchy,\n    fair_elections = v2xel_frefair\n  ) |>\n  group_by(country_id) |> \n  summarize(\n    polyarchy = mean(polyarchy, na.rm = TRUE),\n    fair_elections = mean(fair_elections, na.rm = TRUE)\n  )\n\nglimpse(democracy_scores)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 179\nColumns: 3\n$ country_id     <dbl> 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20…\n$ polyarchy      <dbl> 0.6599524, 0.7645238, 0.9137143, 0.8975238, 0.7366667, …\n$ fair_elections <dbl> 0.7781429, 0.8423810, 0.9628571, 0.9379524, 0.7590000, …\n```\n\n\n:::\n:::\n\nNow we can perform a left join to combine the two datasets based on the V-Dem country codes and the year. We will use the `left_join()` function from `dplyr` to do this. Let's be sure to put the V-Dem data set as our left dataset, since we want to keep all of the V-Dem data and only add the World Bank data where it matches.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform a left join to combine the datasets\nwb_democracy_data <- left_join( \n  democracy_scores, \n  wbdata_all_countries,\n  by = c(\"country_id\" = \"vdem_country_code\")\n)\n\nglimpse(wb_democracy_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 179\nColumns: 7\n$ country_id     <dbl> 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20…\n$ polyarchy      <dbl> 0.6599524, 0.7645238, 0.9137143, 0.8975238, 0.7366667, …\n$ fair_elections <dbl> 0.7781429, 0.8423810, 0.9628571, 0.9379524, 0.7590000, …\n$ iso3c          <chr> \"MEX\", \"SUR\", \"SWE\", \"CHE\", \"GHA\", \"ZAF\", \"JPN\", \"MMR\",…\n$ region         <chr> \"Latin America & Caribbean\", \"Latin America & Caribbean…\n$ gdp_pc         <dbl> 9681.1700, 7938.9413, 48091.5799, 80543.6345, 1457.1354…\n$ population     <dbl> 113311064.9, 549054.4, 9459610.6, 7863746.1, 25596248.3…\n```\n\n\n:::\n:::\n\nNotice here that while we had a common key for the country codes, the columns had different names. Therefore, we specified the `by` argument as a named vector, where we matched the `vdem_country_code` from the World Bank data to the `country_code` in the V-Dem data. \n\nNow let's have a little bit of fun and try a visualizing the relationship between GDP per capita and the V-Dem polyarchy score using `ggplot2`:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(wb_democracy_data, aes(x = gdp_pc, y = polyarchy, size = population, color = region)) +\n  geom_point(alpha = 0.5) +\n  scale_x_log10(labels = scales::label_number(prefix = \"$\", suffix = \"k\")) +\n  scale_size_continuous( # options for customizing population legend\n    name = \"Population\",\n    breaks = c(1e6, 1e7, 5e7, 1e8, 5e8, 1e9),  \n    labels = c(\"1M\", \"10M\", \"50M\", \"100M\", \"500M\", \"1B\")\n  ) +\n  labs(\n    title = \"Wealth and Democracy, 2000 - 2020\",\n    x = \"GDP per Capita\",\n    y = \"V-Dem Polyarchy Score\",\n    color = \"Region\"\n  ) +\n  theme_minimal() +\n  scale_colour_viridis_d(option = \"plasma\", end = 0.9) \n```\n\n::: {.cell-output-display}\n![](module-2.4_files/figure-html/plot-democracy-gdp-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-warning icon=false}\n## Your Turn!!\n- Use the `WDI()` function to download a set of economic indicators for a country or set of countries.\n- Use the `countrycode` package to convert the country codes in your World Bank data to V-Dem codes.\n- Use the `fetchdem()` function to download V-Dem democracy scores for the same countries and years as your World Bank data.\n- Use `left_join()` to merge the two datasets based on the V-Dem country codes and year.\n- Visualize the relationship between one of your economic indicators and a V-Dem democracy score using `ggplot2`.\n:::\n\n",
    "supporting": [
      "module-2.4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}